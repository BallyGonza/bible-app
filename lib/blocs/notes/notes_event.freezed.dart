// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'notes_event.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$NotesEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(NoteModel note) addNote,
    required TResult Function(int index, NoteModel note) editNote,
    required TResult Function(int index) deleteNote,
    required TResult Function(int index, VerseModel verse) addVerse,
    required TResult Function(int index, int verseIndex) removeVerse,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(NoteModel note)? addNote,
    TResult? Function(int index, NoteModel note)? editNote,
    TResult? Function(int index)? deleteNote,
    TResult? Function(int index, VerseModel verse)? addVerse,
    TResult? Function(int index, int verseIndex)? removeVerse,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(NoteModel note)? addNote,
    TResult Function(int index, NoteModel note)? editNote,
    TResult Function(int index)? deleteNote,
    TResult Function(int index, VerseModel verse)? addVerse,
    TResult Function(int index, int verseIndex)? removeVerse,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotesInitialEvent value) init,
    required TResult Function(NotesAddNoteEvent value) addNote,
    required TResult Function(NotesEditNoteEvent value) editNote,
    required TResult Function(NotesDeleteNoteEvent value) deleteNote,
    required TResult Function(NotesAddVerseEvent value) addVerse,
    required TResult Function(NotesRemoveVerseEvent value) removeVerse,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotesInitialEvent value)? init,
    TResult? Function(NotesAddNoteEvent value)? addNote,
    TResult? Function(NotesEditNoteEvent value)? editNote,
    TResult? Function(NotesDeleteNoteEvent value)? deleteNote,
    TResult? Function(NotesAddVerseEvent value)? addVerse,
    TResult? Function(NotesRemoveVerseEvent value)? removeVerse,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotesInitialEvent value)? init,
    TResult Function(NotesAddNoteEvent value)? addNote,
    TResult Function(NotesEditNoteEvent value)? editNote,
    TResult Function(NotesDeleteNoteEvent value)? deleteNote,
    TResult Function(NotesAddVerseEvent value)? addVerse,
    TResult Function(NotesRemoveVerseEvent value)? removeVerse,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NotesEventCopyWith<$Res> {
  factory $NotesEventCopyWith(
          NotesEvent value, $Res Function(NotesEvent) then) =
      _$NotesEventCopyWithImpl<$Res, NotesEvent>;
}

/// @nodoc
class _$NotesEventCopyWithImpl<$Res, $Val extends NotesEvent>
    implements $NotesEventCopyWith<$Res> {
  _$NotesEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$NotesInitialEventImplCopyWith<$Res> {
  factory _$$NotesInitialEventImplCopyWith(_$NotesInitialEventImpl value,
          $Res Function(_$NotesInitialEventImpl) then) =
      __$$NotesInitialEventImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$NotesInitialEventImplCopyWithImpl<$Res>
    extends _$NotesEventCopyWithImpl<$Res, _$NotesInitialEventImpl>
    implements _$$NotesInitialEventImplCopyWith<$Res> {
  __$$NotesInitialEventImplCopyWithImpl(_$NotesInitialEventImpl _value,
      $Res Function(_$NotesInitialEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$NotesInitialEventImpl implements NotesInitialEvent {
  const _$NotesInitialEventImpl();

  @override
  String toString() {
    return 'NotesEvent.init()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$NotesInitialEventImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(NoteModel note) addNote,
    required TResult Function(int index, NoteModel note) editNote,
    required TResult Function(int index) deleteNote,
    required TResult Function(int index, VerseModel verse) addVerse,
    required TResult Function(int index, int verseIndex) removeVerse,
  }) {
    return init();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(NoteModel note)? addNote,
    TResult? Function(int index, NoteModel note)? editNote,
    TResult? Function(int index)? deleteNote,
    TResult? Function(int index, VerseModel verse)? addVerse,
    TResult? Function(int index, int verseIndex)? removeVerse,
  }) {
    return init?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(NoteModel note)? addNote,
    TResult Function(int index, NoteModel note)? editNote,
    TResult Function(int index)? deleteNote,
    TResult Function(int index, VerseModel verse)? addVerse,
    TResult Function(int index, int verseIndex)? removeVerse,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotesInitialEvent value) init,
    required TResult Function(NotesAddNoteEvent value) addNote,
    required TResult Function(NotesEditNoteEvent value) editNote,
    required TResult Function(NotesDeleteNoteEvent value) deleteNote,
    required TResult Function(NotesAddVerseEvent value) addVerse,
    required TResult Function(NotesRemoveVerseEvent value) removeVerse,
  }) {
    return init(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotesInitialEvent value)? init,
    TResult? Function(NotesAddNoteEvent value)? addNote,
    TResult? Function(NotesEditNoteEvent value)? editNote,
    TResult? Function(NotesDeleteNoteEvent value)? deleteNote,
    TResult? Function(NotesAddVerseEvent value)? addVerse,
    TResult? Function(NotesRemoveVerseEvent value)? removeVerse,
  }) {
    return init?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotesInitialEvent value)? init,
    TResult Function(NotesAddNoteEvent value)? addNote,
    TResult Function(NotesEditNoteEvent value)? editNote,
    TResult Function(NotesDeleteNoteEvent value)? deleteNote,
    TResult Function(NotesAddVerseEvent value)? addVerse,
    TResult Function(NotesRemoveVerseEvent value)? removeVerse,
    required TResult orElse(),
  }) {
    if (init != null) {
      return init(this);
    }
    return orElse();
  }
}

abstract class NotesInitialEvent implements NotesEvent {
  const factory NotesInitialEvent() = _$NotesInitialEventImpl;
}

/// @nodoc
abstract class _$$NotesAddNoteEventImplCopyWith<$Res> {
  factory _$$NotesAddNoteEventImplCopyWith(_$NotesAddNoteEventImpl value,
          $Res Function(_$NotesAddNoteEventImpl) then) =
      __$$NotesAddNoteEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({NoteModel note});
}

/// @nodoc
class __$$NotesAddNoteEventImplCopyWithImpl<$Res>
    extends _$NotesEventCopyWithImpl<$Res, _$NotesAddNoteEventImpl>
    implements _$$NotesAddNoteEventImplCopyWith<$Res> {
  __$$NotesAddNoteEventImplCopyWithImpl(_$NotesAddNoteEventImpl _value,
      $Res Function(_$NotesAddNoteEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? note = null,
  }) {
    return _then(_$NotesAddNoteEventImpl(
      null == note
          ? _value.note
          : note // ignore: cast_nullable_to_non_nullable
              as NoteModel,
    ));
  }
}

/// @nodoc

class _$NotesAddNoteEventImpl implements NotesAddNoteEvent {
  const _$NotesAddNoteEventImpl(this.note);

  @override
  final NoteModel note;

  @override
  String toString() {
    return 'NotesEvent.addNote(note: $note)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotesAddNoteEventImpl &&
            (identical(other.note, note) || other.note == note));
  }

  @override
  int get hashCode => Object.hash(runtimeType, note);

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NotesAddNoteEventImplCopyWith<_$NotesAddNoteEventImpl> get copyWith =>
      __$$NotesAddNoteEventImplCopyWithImpl<_$NotesAddNoteEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(NoteModel note) addNote,
    required TResult Function(int index, NoteModel note) editNote,
    required TResult Function(int index) deleteNote,
    required TResult Function(int index, VerseModel verse) addVerse,
    required TResult Function(int index, int verseIndex) removeVerse,
  }) {
    return addNote(note);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(NoteModel note)? addNote,
    TResult? Function(int index, NoteModel note)? editNote,
    TResult? Function(int index)? deleteNote,
    TResult? Function(int index, VerseModel verse)? addVerse,
    TResult? Function(int index, int verseIndex)? removeVerse,
  }) {
    return addNote?.call(note);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(NoteModel note)? addNote,
    TResult Function(int index, NoteModel note)? editNote,
    TResult Function(int index)? deleteNote,
    TResult Function(int index, VerseModel verse)? addVerse,
    TResult Function(int index, int verseIndex)? removeVerse,
    required TResult orElse(),
  }) {
    if (addNote != null) {
      return addNote(note);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotesInitialEvent value) init,
    required TResult Function(NotesAddNoteEvent value) addNote,
    required TResult Function(NotesEditNoteEvent value) editNote,
    required TResult Function(NotesDeleteNoteEvent value) deleteNote,
    required TResult Function(NotesAddVerseEvent value) addVerse,
    required TResult Function(NotesRemoveVerseEvent value) removeVerse,
  }) {
    return addNote(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotesInitialEvent value)? init,
    TResult? Function(NotesAddNoteEvent value)? addNote,
    TResult? Function(NotesEditNoteEvent value)? editNote,
    TResult? Function(NotesDeleteNoteEvent value)? deleteNote,
    TResult? Function(NotesAddVerseEvent value)? addVerse,
    TResult? Function(NotesRemoveVerseEvent value)? removeVerse,
  }) {
    return addNote?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotesInitialEvent value)? init,
    TResult Function(NotesAddNoteEvent value)? addNote,
    TResult Function(NotesEditNoteEvent value)? editNote,
    TResult Function(NotesDeleteNoteEvent value)? deleteNote,
    TResult Function(NotesAddVerseEvent value)? addVerse,
    TResult Function(NotesRemoveVerseEvent value)? removeVerse,
    required TResult orElse(),
  }) {
    if (addNote != null) {
      return addNote(this);
    }
    return orElse();
  }
}

abstract class NotesAddNoteEvent implements NotesEvent {
  const factory NotesAddNoteEvent(final NoteModel note) =
      _$NotesAddNoteEventImpl;

  NoteModel get note;

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NotesAddNoteEventImplCopyWith<_$NotesAddNoteEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NotesEditNoteEventImplCopyWith<$Res> {
  factory _$$NotesEditNoteEventImplCopyWith(_$NotesEditNoteEventImpl value,
          $Res Function(_$NotesEditNoteEventImpl) then) =
      __$$NotesEditNoteEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index, NoteModel note});
}

/// @nodoc
class __$$NotesEditNoteEventImplCopyWithImpl<$Res>
    extends _$NotesEventCopyWithImpl<$Res, _$NotesEditNoteEventImpl>
    implements _$$NotesEditNoteEventImplCopyWith<$Res> {
  __$$NotesEditNoteEventImplCopyWithImpl(_$NotesEditNoteEventImpl _value,
      $Res Function(_$NotesEditNoteEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? note = null,
  }) {
    return _then(_$NotesEditNoteEventImpl(
      null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      null == note
          ? _value.note
          : note // ignore: cast_nullable_to_non_nullable
              as NoteModel,
    ));
  }
}

/// @nodoc

class _$NotesEditNoteEventImpl implements NotesEditNoteEvent {
  const _$NotesEditNoteEventImpl(this.index, this.note);

  @override
  final int index;
  @override
  final NoteModel note;

  @override
  String toString() {
    return 'NotesEvent.editNote(index: $index, note: $note)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotesEditNoteEventImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.note, note) || other.note == note));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index, note);

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NotesEditNoteEventImplCopyWith<_$NotesEditNoteEventImpl> get copyWith =>
      __$$NotesEditNoteEventImplCopyWithImpl<_$NotesEditNoteEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(NoteModel note) addNote,
    required TResult Function(int index, NoteModel note) editNote,
    required TResult Function(int index) deleteNote,
    required TResult Function(int index, VerseModel verse) addVerse,
    required TResult Function(int index, int verseIndex) removeVerse,
  }) {
    return editNote(index, note);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(NoteModel note)? addNote,
    TResult? Function(int index, NoteModel note)? editNote,
    TResult? Function(int index)? deleteNote,
    TResult? Function(int index, VerseModel verse)? addVerse,
    TResult? Function(int index, int verseIndex)? removeVerse,
  }) {
    return editNote?.call(index, note);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(NoteModel note)? addNote,
    TResult Function(int index, NoteModel note)? editNote,
    TResult Function(int index)? deleteNote,
    TResult Function(int index, VerseModel verse)? addVerse,
    TResult Function(int index, int verseIndex)? removeVerse,
    required TResult orElse(),
  }) {
    if (editNote != null) {
      return editNote(index, note);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotesInitialEvent value) init,
    required TResult Function(NotesAddNoteEvent value) addNote,
    required TResult Function(NotesEditNoteEvent value) editNote,
    required TResult Function(NotesDeleteNoteEvent value) deleteNote,
    required TResult Function(NotesAddVerseEvent value) addVerse,
    required TResult Function(NotesRemoveVerseEvent value) removeVerse,
  }) {
    return editNote(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotesInitialEvent value)? init,
    TResult? Function(NotesAddNoteEvent value)? addNote,
    TResult? Function(NotesEditNoteEvent value)? editNote,
    TResult? Function(NotesDeleteNoteEvent value)? deleteNote,
    TResult? Function(NotesAddVerseEvent value)? addVerse,
    TResult? Function(NotesRemoveVerseEvent value)? removeVerse,
  }) {
    return editNote?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotesInitialEvent value)? init,
    TResult Function(NotesAddNoteEvent value)? addNote,
    TResult Function(NotesEditNoteEvent value)? editNote,
    TResult Function(NotesDeleteNoteEvent value)? deleteNote,
    TResult Function(NotesAddVerseEvent value)? addVerse,
    TResult Function(NotesRemoveVerseEvent value)? removeVerse,
    required TResult orElse(),
  }) {
    if (editNote != null) {
      return editNote(this);
    }
    return orElse();
  }
}

abstract class NotesEditNoteEvent implements NotesEvent {
  const factory NotesEditNoteEvent(final int index, final NoteModel note) =
      _$NotesEditNoteEventImpl;

  int get index;
  NoteModel get note;

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NotesEditNoteEventImplCopyWith<_$NotesEditNoteEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NotesDeleteNoteEventImplCopyWith<$Res> {
  factory _$$NotesDeleteNoteEventImplCopyWith(_$NotesDeleteNoteEventImpl value,
          $Res Function(_$NotesDeleteNoteEventImpl) then) =
      __$$NotesDeleteNoteEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index});
}

/// @nodoc
class __$$NotesDeleteNoteEventImplCopyWithImpl<$Res>
    extends _$NotesEventCopyWithImpl<$Res, _$NotesDeleteNoteEventImpl>
    implements _$$NotesDeleteNoteEventImplCopyWith<$Res> {
  __$$NotesDeleteNoteEventImplCopyWithImpl(_$NotesDeleteNoteEventImpl _value,
      $Res Function(_$NotesDeleteNoteEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
  }) {
    return _then(_$NotesDeleteNoteEventImpl(
      null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$NotesDeleteNoteEventImpl implements NotesDeleteNoteEvent {
  const _$NotesDeleteNoteEventImpl(this.index);

  @override
  final int index;

  @override
  String toString() {
    return 'NotesEvent.deleteNote(index: $index)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotesDeleteNoteEventImpl &&
            (identical(other.index, index) || other.index == index));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index);

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NotesDeleteNoteEventImplCopyWith<_$NotesDeleteNoteEventImpl>
      get copyWith =>
          __$$NotesDeleteNoteEventImplCopyWithImpl<_$NotesDeleteNoteEventImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(NoteModel note) addNote,
    required TResult Function(int index, NoteModel note) editNote,
    required TResult Function(int index) deleteNote,
    required TResult Function(int index, VerseModel verse) addVerse,
    required TResult Function(int index, int verseIndex) removeVerse,
  }) {
    return deleteNote(index);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(NoteModel note)? addNote,
    TResult? Function(int index, NoteModel note)? editNote,
    TResult? Function(int index)? deleteNote,
    TResult? Function(int index, VerseModel verse)? addVerse,
    TResult? Function(int index, int verseIndex)? removeVerse,
  }) {
    return deleteNote?.call(index);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(NoteModel note)? addNote,
    TResult Function(int index, NoteModel note)? editNote,
    TResult Function(int index)? deleteNote,
    TResult Function(int index, VerseModel verse)? addVerse,
    TResult Function(int index, int verseIndex)? removeVerse,
    required TResult orElse(),
  }) {
    if (deleteNote != null) {
      return deleteNote(index);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotesInitialEvent value) init,
    required TResult Function(NotesAddNoteEvent value) addNote,
    required TResult Function(NotesEditNoteEvent value) editNote,
    required TResult Function(NotesDeleteNoteEvent value) deleteNote,
    required TResult Function(NotesAddVerseEvent value) addVerse,
    required TResult Function(NotesRemoveVerseEvent value) removeVerse,
  }) {
    return deleteNote(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotesInitialEvent value)? init,
    TResult? Function(NotesAddNoteEvent value)? addNote,
    TResult? Function(NotesEditNoteEvent value)? editNote,
    TResult? Function(NotesDeleteNoteEvent value)? deleteNote,
    TResult? Function(NotesAddVerseEvent value)? addVerse,
    TResult? Function(NotesRemoveVerseEvent value)? removeVerse,
  }) {
    return deleteNote?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotesInitialEvent value)? init,
    TResult Function(NotesAddNoteEvent value)? addNote,
    TResult Function(NotesEditNoteEvent value)? editNote,
    TResult Function(NotesDeleteNoteEvent value)? deleteNote,
    TResult Function(NotesAddVerseEvent value)? addVerse,
    TResult Function(NotesRemoveVerseEvent value)? removeVerse,
    required TResult orElse(),
  }) {
    if (deleteNote != null) {
      return deleteNote(this);
    }
    return orElse();
  }
}

abstract class NotesDeleteNoteEvent implements NotesEvent {
  const factory NotesDeleteNoteEvent(final int index) =
      _$NotesDeleteNoteEventImpl;

  int get index;

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NotesDeleteNoteEventImplCopyWith<_$NotesDeleteNoteEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NotesAddVerseEventImplCopyWith<$Res> {
  factory _$$NotesAddVerseEventImplCopyWith(_$NotesAddVerseEventImpl value,
          $Res Function(_$NotesAddVerseEventImpl) then) =
      __$$NotesAddVerseEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index, VerseModel verse});
}

/// @nodoc
class __$$NotesAddVerseEventImplCopyWithImpl<$Res>
    extends _$NotesEventCopyWithImpl<$Res, _$NotesAddVerseEventImpl>
    implements _$$NotesAddVerseEventImplCopyWith<$Res> {
  __$$NotesAddVerseEventImplCopyWithImpl(_$NotesAddVerseEventImpl _value,
      $Res Function(_$NotesAddVerseEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? verse = null,
  }) {
    return _then(_$NotesAddVerseEventImpl(
      null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      null == verse
          ? _value.verse
          : verse // ignore: cast_nullable_to_non_nullable
              as VerseModel,
    ));
  }
}

/// @nodoc

class _$NotesAddVerseEventImpl implements NotesAddVerseEvent {
  const _$NotesAddVerseEventImpl(this.index, this.verse);

  @override
  final int index;
  @override
  final VerseModel verse;

  @override
  String toString() {
    return 'NotesEvent.addVerse(index: $index, verse: $verse)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotesAddVerseEventImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.verse, verse) || other.verse == verse));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index, verse);

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NotesAddVerseEventImplCopyWith<_$NotesAddVerseEventImpl> get copyWith =>
      __$$NotesAddVerseEventImplCopyWithImpl<_$NotesAddVerseEventImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(NoteModel note) addNote,
    required TResult Function(int index, NoteModel note) editNote,
    required TResult Function(int index) deleteNote,
    required TResult Function(int index, VerseModel verse) addVerse,
    required TResult Function(int index, int verseIndex) removeVerse,
  }) {
    return addVerse(index, verse);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(NoteModel note)? addNote,
    TResult? Function(int index, NoteModel note)? editNote,
    TResult? Function(int index)? deleteNote,
    TResult? Function(int index, VerseModel verse)? addVerse,
    TResult? Function(int index, int verseIndex)? removeVerse,
  }) {
    return addVerse?.call(index, verse);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(NoteModel note)? addNote,
    TResult Function(int index, NoteModel note)? editNote,
    TResult Function(int index)? deleteNote,
    TResult Function(int index, VerseModel verse)? addVerse,
    TResult Function(int index, int verseIndex)? removeVerse,
    required TResult orElse(),
  }) {
    if (addVerse != null) {
      return addVerse(index, verse);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotesInitialEvent value) init,
    required TResult Function(NotesAddNoteEvent value) addNote,
    required TResult Function(NotesEditNoteEvent value) editNote,
    required TResult Function(NotesDeleteNoteEvent value) deleteNote,
    required TResult Function(NotesAddVerseEvent value) addVerse,
    required TResult Function(NotesRemoveVerseEvent value) removeVerse,
  }) {
    return addVerse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotesInitialEvent value)? init,
    TResult? Function(NotesAddNoteEvent value)? addNote,
    TResult? Function(NotesEditNoteEvent value)? editNote,
    TResult? Function(NotesDeleteNoteEvent value)? deleteNote,
    TResult? Function(NotesAddVerseEvent value)? addVerse,
    TResult? Function(NotesRemoveVerseEvent value)? removeVerse,
  }) {
    return addVerse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotesInitialEvent value)? init,
    TResult Function(NotesAddNoteEvent value)? addNote,
    TResult Function(NotesEditNoteEvent value)? editNote,
    TResult Function(NotesDeleteNoteEvent value)? deleteNote,
    TResult Function(NotesAddVerseEvent value)? addVerse,
    TResult Function(NotesRemoveVerseEvent value)? removeVerse,
    required TResult orElse(),
  }) {
    if (addVerse != null) {
      return addVerse(this);
    }
    return orElse();
  }
}

abstract class NotesAddVerseEvent implements NotesEvent {
  const factory NotesAddVerseEvent(final int index, final VerseModel verse) =
      _$NotesAddVerseEventImpl;

  int get index;
  VerseModel get verse;

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NotesAddVerseEventImplCopyWith<_$NotesAddVerseEventImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$NotesRemoveVerseEventImplCopyWith<$Res> {
  factory _$$NotesRemoveVerseEventImplCopyWith(
          _$NotesRemoveVerseEventImpl value,
          $Res Function(_$NotesRemoveVerseEventImpl) then) =
      __$$NotesRemoveVerseEventImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int index, int verseIndex});
}

/// @nodoc
class __$$NotesRemoveVerseEventImplCopyWithImpl<$Res>
    extends _$NotesEventCopyWithImpl<$Res, _$NotesRemoveVerseEventImpl>
    implements _$$NotesRemoveVerseEventImplCopyWith<$Res> {
  __$$NotesRemoveVerseEventImplCopyWithImpl(_$NotesRemoveVerseEventImpl _value,
      $Res Function(_$NotesRemoveVerseEventImpl) _then)
      : super(_value, _then);

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? index = null,
    Object? verseIndex = null,
  }) {
    return _then(_$NotesRemoveVerseEventImpl(
      null == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int,
      null == verseIndex
          ? _value.verseIndex
          : verseIndex // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$NotesRemoveVerseEventImpl implements NotesRemoveVerseEvent {
  const _$NotesRemoveVerseEventImpl(this.index, this.verseIndex);

  @override
  final int index;
  @override
  final int verseIndex;

  @override
  String toString() {
    return 'NotesEvent.removeVerse(index: $index, verseIndex: $verseIndex)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NotesRemoveVerseEventImpl &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.verseIndex, verseIndex) ||
                other.verseIndex == verseIndex));
  }

  @override
  int get hashCode => Object.hash(runtimeType, index, verseIndex);

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NotesRemoveVerseEventImplCopyWith<_$NotesRemoveVerseEventImpl>
      get copyWith => __$$NotesRemoveVerseEventImplCopyWithImpl<
          _$NotesRemoveVerseEventImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() init,
    required TResult Function(NoteModel note) addNote,
    required TResult Function(int index, NoteModel note) editNote,
    required TResult Function(int index) deleteNote,
    required TResult Function(int index, VerseModel verse) addVerse,
    required TResult Function(int index, int verseIndex) removeVerse,
  }) {
    return removeVerse(index, verseIndex);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? init,
    TResult? Function(NoteModel note)? addNote,
    TResult? Function(int index, NoteModel note)? editNote,
    TResult? Function(int index)? deleteNote,
    TResult? Function(int index, VerseModel verse)? addVerse,
    TResult? Function(int index, int verseIndex)? removeVerse,
  }) {
    return removeVerse?.call(index, verseIndex);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? init,
    TResult Function(NoteModel note)? addNote,
    TResult Function(int index, NoteModel note)? editNote,
    TResult Function(int index)? deleteNote,
    TResult Function(int index, VerseModel verse)? addVerse,
    TResult Function(int index, int verseIndex)? removeVerse,
    required TResult orElse(),
  }) {
    if (removeVerse != null) {
      return removeVerse(index, verseIndex);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(NotesInitialEvent value) init,
    required TResult Function(NotesAddNoteEvent value) addNote,
    required TResult Function(NotesEditNoteEvent value) editNote,
    required TResult Function(NotesDeleteNoteEvent value) deleteNote,
    required TResult Function(NotesAddVerseEvent value) addVerse,
    required TResult Function(NotesRemoveVerseEvent value) removeVerse,
  }) {
    return removeVerse(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(NotesInitialEvent value)? init,
    TResult? Function(NotesAddNoteEvent value)? addNote,
    TResult? Function(NotesEditNoteEvent value)? editNote,
    TResult? Function(NotesDeleteNoteEvent value)? deleteNote,
    TResult? Function(NotesAddVerseEvent value)? addVerse,
    TResult? Function(NotesRemoveVerseEvent value)? removeVerse,
  }) {
    return removeVerse?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(NotesInitialEvent value)? init,
    TResult Function(NotesAddNoteEvent value)? addNote,
    TResult Function(NotesEditNoteEvent value)? editNote,
    TResult Function(NotesDeleteNoteEvent value)? deleteNote,
    TResult Function(NotesAddVerseEvent value)? addVerse,
    TResult Function(NotesRemoveVerseEvent value)? removeVerse,
    required TResult orElse(),
  }) {
    if (removeVerse != null) {
      return removeVerse(this);
    }
    return orElse();
  }
}

abstract class NotesRemoveVerseEvent implements NotesEvent {
  const factory NotesRemoveVerseEvent(final int index, final int verseIndex) =
      _$NotesRemoveVerseEventImpl;

  int get index;
  int get verseIndex;

  /// Create a copy of NotesEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NotesRemoveVerseEventImplCopyWith<_$NotesRemoveVerseEventImpl>
      get copyWith => throw _privateConstructorUsedError;
}
